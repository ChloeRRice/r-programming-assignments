daily_counts <- df %>%
group_by(Date, .data[[user_col]]) %>%
summarise(DailyMessages = n(), .groups = "drop")
# Identify top sender for each day
top_senders <- daily_counts %>%
group_by(Date) %>%
slice_max(order_by = DailyMessages, n = 1, with_ties = FALSE) %>%
ungroup()
# Plot top sender per day
ggplot(top_senders, aes(x = Date, y = DailyMessages, fill = .data[[user_col]])) +
geom_col() +
labs(
title = "Top Message Sender per Day",
x = "Date",
y = "Number of Messages",
fill = "Username"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
}
plot_top_sender_per_day(TimeClean, user_col = "Author")
plot_user_activity_by_day <- function(df, datetime_col = "Timestamp_clean", user_col = "Username", top_n = 10) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Extract day of week
df <- df %>%
mutate(
DayOfWeek = weekdays(as.Date(.data[[datetime_col]]))
)
# Identify top N users overall
top_users <- df %>%
count(.data[[user_col]], name = "TotalMessages") %>%
arrange(desc(TotalMessages)) %>%
slice_head(n = top_n) %>%
pull(.data[[user_col]])
# Filter for top users
df_top <- df %>%
filter(.data[[user_col]] %in% top_users)
# Count messages per user per day of week
user_day_counts <- df_top %>%
group_by(.data[[user_col]], DayOfWeek) %>%
summarise(MessageCount = n(), .groups = "drop")
# Order days of the week
day_levels <- c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")
user_day_counts$DayOfWeek <- factor(user_day_counts$DayOfWeek, levels = day_levels)
# Plot using geom_count
ggplot(user_day_counts, aes(x = DayOfWeek, y = .data[[user_col]])) +
geom_count(aes(size = MessageCount), color = "#4E79A7", alpha = 0.7) +
scale_size_area(max_size = 15) +
labs(
title = paste("Top", top_n, "Users Activity by Day of Week"),
x = "Day of Week",
y = "Username",
size = "Message Count"
) +
theme_minimal(base_size = 14)
}
plot_user_activity_by_day <- function(df, datetime_col = "Timestamp_clean", user_col = "Author", top_n = 10) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Extract day of week
df <- df %>%
mutate(
DayOfWeek = weekdays(as.Date(.data[[datetime_col]]))
)
# Identify top N users overall
top_users <- df %>%
count(.data[[user_col]], name = "TotalMessages") %>%
arrange(desc(TotalMessages)) %>%
slice_head(n = top_n) %>%
pull(.data[[user_col]])
# Filter for top users
df_top <- df %>%
filter(.data[[user_col]] %in% top_users)
# Count messages per user per day of week
user_day_counts <- df_top %>%
group_by(.data[[user_col]], DayOfWeek) %>%
summarise(MessageCount = n(), .groups = "drop")
# Order days of the week
day_levels <- c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")
user_day_counts$DayOfWeek <- factor(user_day_counts$DayOfWeek, levels = day_levels)
# Plot using geom_count
ggplot(user_day_counts, aes(x = DayOfWeek, y = .data[[user_col]])) +
geom_count(aes(size = MessageCount), color = "#4E79A7", alpha = 0.7) +
scale_size_area(max_size = 15) +
labs(
title = paste("Top", top_n, "Users Activity by Day of Week"),
x = "Day of Week",
y = "Username",
size = "Message Count"
) +
theme_minimal(base_size = 14)
}
plot_user_activity_by_day(TimeClean)
Discord_HourDensity <- function(df, datetime_col = "Timestamp_clean") {
# Check column exists
if (!datetime_col %in% names(df)) {
stop("Datetime column not found in the data frame.")
}
# Extract fractional hour (0-24)
df <- df %>%
mutate(
HourFraction = as.numeric(format(.data[[datetime_col]], "%H")) +
as.numeric(format(.data[[datetime_col]], "%M")) / 60 +
as.numeric(format(.data[[datetime_col]], "%S")) / 3600
)
# Plot smoothed density
ggplot(df, aes(x = HourFraction)) +
geom_density(fill = "#76B7B2", alpha = 0.6, linewidth = 1) +
scale_x_continuous(breaks = 0:23, labels = sprintf("%02d:00", 0:23)) +
labs(
title = "Smoothed Density of Messages by Time of Day",
x = "Hour of Day",
y = "Density"
) +
theme_dark(base_size = 14)
}
Discord_HourDensity(TimeClean)
Discord_TopUserActivity <- function(df, datetime_col = "Timestamp_clean", user_col = "Author", top_n = 5, smooth = FALSE) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Identify top N users
top_users <- df %>%
count(.data[[user_col]], name = "TotalMessages") %>%
arrange(desc(TotalMessages)) %>%
slice_head(n = top_n) %>%
pull(.data[[user_col]])
# Filter for top users
df_top <- df %>%
filter(.data[[user_col]] %in% top_users) %>%
mutate(Date = as.Date(.data[[datetime_col]]))
# Aggregate messages per user per day
df_daily <- df_top %>%
group_by(.data[[user_col]], Date) %>%
summarise(DailyMessages = n(), .groups = "drop")
# Plot daily messages
p <- ggplot(df_daily, aes(x = Date, y = DailyMessages, color = .data[[user_col]])) +
geom_line(linewidth = 1.2) +
geom_point(size = 2, alpha = 0.7) +
labs(
title = paste("Daily Messages Over Time - Top", top_n, "Users"),
x = "Date",
y = "Daily Messages",
color = "Username"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
# Optional smoothing
if (smooth) {
p <- p + geom_smooth(se = FALSE, method = "loess", linewidth = 0.8, linetype = "dashed")
}
return(p)
}
Discord_TopUserActivity()
Discord_TopUserActivity(TimeClean)
document()
rm(list = c("Discord_HeatMap", "Discord_HourDensity",
"Discord_TimeConvert", "Discord_TopDays", "Discord_TopUserActivity",
"Discord_TopUsers", "Discord_TopUsersCumulative"))
View(clean_timestamp)
library(readxl)
FinalProjectData <- read_excel("Data/FinalProjectData.xlsx",
sheet = "MessageHistory")
View(FinalProjectData)
Discord_TimeConvert <- function(df, column = "Date") {
# Remove fractional seconds
cleaned <- gsub("(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}).*", "\\1", df[[column]])
# Convert "T" to space for standard POSIX parsing
cleaned <- gsub("T", " ", cleaned)
# Convert to POSIXct
df$Timestamp_clean <- as.POSIXct(
cleaned,
format = "%Y-%m-%d %H:%M:%S",
tz = "EST"
)
return(df)
}
View(FinalProjectData)
CleanTime <- Discord_TimeConvert(FinalProjectData)
View(CleanTime)
Discord_TopUsers(CleanTime)
Discord_TopUsers(CleanTime)
Discord_TopDays(CleanTime)
Discord_HeatMap(CleanTime)
Discord_HeatMap(CleanTime)
Discord_TopUsersCumulative(CleanTime)
Discord_HourDensity(CleanTime)
Discord_Top36hr <- function(df, datetime_col = "Timestamp_clean", user_col = "Username", top_n = 5) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Sort dataset by datetime
df <- df %>% arrange(.data[[datetime_col]])
# Initialize list to store counts
rolling_counts <- list()
# Vector of timestamps
timestamps <- df[[datetime_col]]
# Loop through each row to define rolling 36-hour window starting at that timestamp
for (i in seq_along(timestamps)) {
window_start <- timestamps[i]
window_end <- window_start + 36*60*60  # 36 hours in seconds
# Filter messages within this window
df_window <- df %>%
filter(.data[[datetime_col]] >= window_start & .data[[datetime_col]] <= window_end)
# Count messages per user in this window
if (nrow(df_window) > 0) {
counts <- df_window %>%
count(.data[[user_col]], name = "MessageCount") %>%
mutate(WindowStart = window_start, WindowEnd = window_end)
rolling_counts[[i]] <- counts
}
}
# Combine all windows into one data frame
all_counts <- bind_rows(rolling_counts)
# Find the window/user combination with the maximum messages
top_users <- all_counts %>%
arrange(desc(MessageCount)) %>%
slice_head(n = top_n)
return(top_users)
}
Discord_Top36hr <- function(df, datetime_col = "Timestamp_clean", user_col = "Author", top_n = 5) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Sort dataset by datetime
df <- df %>% arrange(.data[[datetime_col]])
# Initialize list to store counts
rolling_counts <- list()
# Vector of timestamps
timestamps <- df[[datetime_col]]
# Loop through each row to define rolling 36-hour window starting at that timestamp
for (i in seq_along(timestamps)) {
window_start <- timestamps[i]
window_end <- window_start + 36*60*60  # 36 hours in seconds
# Filter messages within this window
df_window <- df %>%
filter(.data[[datetime_col]] >= window_start & .data[[datetime_col]] <= window_end)
# Count messages per user in this window
if (nrow(df_window) > 0) {
counts <- df_window %>%
count(.data[[user_col]], name = "MessageCount") %>%
mutate(WindowStart = window_start, WindowEnd = window_end)
rolling_counts[[i]] <- counts
}
}
# Combine all windows into one data frame
all_counts <- bind_rows(rolling_counts)
# Find the window/user combination with the maximum messages
top_users <- all_counts %>%
arrange(desc(MessageCount)) %>%
slice_head(n = top_n)
return(top_users)
}
Discord_Top36hr(CleanTime)
Discord_Top36hr(CleanTime, top_n = 20)
max_messages_36hr <- function(df, datetime_col = "Timestamp_clean", user_col = "Username") {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Sort dataset by datetime
df <- df %>% arrange(.data[[datetime_col]])
# Initialize result list
result <- list()
# Get unique users
users <- unique(df[[user_col]])
for (user in users) {
# Subset data for this user
user_times <- df %>%
filter(.data[[user_col]] == user) %>%
pull(.data[[datetime_col]])
# Initialize vector to store max counts
max_count <- 0
start_idx <- 1
# Sliding window approach
for (end_idx in seq_along(user_times)) {
# Move start_idx forward until window is within 36 hours
while (difftime(user_times[end_idx], user_times[start_idx], units = "hours") > 36) {
start_idx <- start_idx + 1
}
# Number of messages in current window
count_window <- end_idx - start_idx + 1
if (count_window > max_count) {
max_count <- count_window
}
}
result[[user]] <- max_count
}
# Convert to data frame and rank
result_df <- tibble(
Username = names(result),
MaxMessages36hr = unlist(result)
) %>%
arrange(desc(MaxMessages36hr)) %>%
mutate(Rank = row_number())
return(result_df)
}
max_messages_36hr <- function(df, datetime_col = "Timestamp_clean", user_col = "Author") {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Sort dataset by datetime
df <- df %>% arrange(.data[[datetime_col]])
# Initialize result list
result <- list()
# Get unique users
users <- unique(df[[user_col]])
for (user in users) {
# Subset data for this user
user_times <- df %>%
filter(.data[[user_col]] == user) %>%
pull(.data[[datetime_col]])
# Initialize vector to store max counts
max_count <- 0
start_idx <- 1
# Sliding window approach
for (end_idx in seq_along(user_times)) {
# Move start_idx forward until window is within 36 hours
while (difftime(user_times[end_idx], user_times[start_idx], units = "hours") > 36) {
start_idx <- start_idx + 1
}
# Number of messages in current window
count_window <- end_idx - start_idx + 1
if (count_window > max_count) {
max_count <- count_window
}
}
result[[user]] <- max_count
}
# Convert to data frame and rank
result_df <- tibble(
Username = names(result),
MaxMessages36hr = unlist(result)
) %>%
arrange(desc(MaxMessages36hr)) %>%
mutate(Rank = row_number())
return(result_df)
}
max_messages_36hr(CleanTime)
Discord_Record <- function(df, datetime_col = "Timestamp_clean", user_col = "Author", search_window = 36) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Sort dataset by datetime
df <- df %>% arrange(.data[[datetime_col]])
# Initialize result list
result <- list()
# Get unique users
users <- unique(df[[user_col]])
for (user in users) {
# Subset data for this user
user_times <- df %>%
filter(.data[[user_col]] == user) %>%
pull(.data[[datetime_col]])
# Initialize vector to store max counts
max_count <- 0
start_idx <- 1
# Sliding window approach
for (end_idx in seq_along(user_times)) {
# Move start_idx forward until window is within 36 hours
while (difftime(user_times[end_idx], user_times[start_idx], units = "hours") > search_window) {
start_idx <- start_idx + 1
}
# Number of messages in current window
count_window <- end_idx - start_idx + 1
if (count_window > max_count) {
max_count <- count_window
}
}
result[[user]] <- max_count
}
# Convert to data frame and rank
result_df <- tibble(
Username = names(result),
MaxMessages = unlist(result)
) %>%
arrange(desc(MaxMessages)) %>%
mutate(Rank = row_number())
return(result_df)
}
Discord_Record(CleanTime, search_window = 12)
document()
rm(list = c("Discord_Record", "Discord_TimeConvert"))
CleanTime <- Discord_Record(CleanTime, search_window = 12)
CleanTime <- Discord_Record(CleanTime, search_window = 12)
CleanTime <- Discord_TimeConvert(FinalProjectData)
Discord_Record(CleanTime, search_window = 12)
Discord_TopUserActivity(CleanTime)
Discord_DailyTop <- function(df, datetime_col = "Timestamp_clean", user_col = "Author") {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Convert to date
df <- df %>%
mutate(Date = as.Date(.data[[datetime_col]]))
# Count messages per user per day
daily_counts <- df %>%
group_by(Date, .data[[user_col]]) %>%
summarise(DailyMessages = n(), .groups = "drop")
# Identify top sender for each day
top_senders <- daily_counts %>%
group_by(Date) %>%
slice_max(order_by = DailyMessages, n = 1, with_ties = FALSE) %>%
ungroup()
# Plot top sender per day
ggplot(top_senders, aes(x = Date, y = DailyMessages, fill = .data[[user_col]])) +
geom_col() +
labs(
title = "Top Message Sender per Day",
x = "Date",
y = "Number of Messages",
fill = "Username"
) +
theme_minimal(base_size = 14) +
theme(legend.position = "bottom")
}
Discord_DailyTop(CleanTime)
Discord_UserDailyActivity <- function(df, datetime_col = "Timestamp_clean", user_col = "Author", top_n = 10) {
# Check columns exist
if (!datetime_col %in% names(df) | !user_col %in% names(df)) {
stop("Datetime or Username column not found in the data frame.")
}
# Extract day of week
df <- df %>%
mutate(
DayOfWeek = weekdays(as.Date(.data[[datetime_col]]))
)
# Identify top N users overall
top_users <- df %>%
count(.data[[user_col]], name = "TotalMessages") %>%
arrange(desc(TotalMessages)) %>%
slice_head(n = top_n) %>%
pull(.data[[user_col]])
# Filter for top users
df_top <- df %>%
filter(.data[[user_col]] %in% top_users)
# Count messages per user per day of week
user_day_counts <- df_top %>%
group_by(.data[[user_col]], DayOfWeek) %>%
summarise(MessageCount = n(), .groups = "drop")
# Order days of the week
day_levels <- c("Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday")
user_day_counts$DayOfWeek <- factor(user_day_counts$DayOfWeek, levels = day_levels)
# Plot using geom_count
ggplot(user_day_counts, aes(x = DayOfWeek, y = .data[[user_col]])) +
geom_count(aes(size = MessageCount), color = "#4E79A7", alpha = 0.7) +
scale_size_area(max_size = 15) +
labs(
title = paste("Top", top_n, "Users Activity by Day of Week"),
x = "Day of Week",
y = "Username",
size = "Message Count"
) +
theme_minimal(base_size = 14)
}
Discord_UserDailyActivity()
Discord_UserDailyActivity(CleanTime)
Discord_HourDensity(CleanTime)
Discord_HourDensity <- function(df, datetime_col = "Timestamp_clean") {
# Check column exists
if (!datetime_col %in% names(df)) {
stop("Datetime column not found in the data frame.")
}
# Extract fractional hour (0-24)
df <- df %>%
mutate(
HourFraction = as.numeric(format(.data[[datetime_col]], "%H")) +
as.numeric(format(.data[[datetime_col]], "%M")) / 60 +
as.numeric(format(.data[[datetime_col]], "%S")) / 3600
)
# Plot smoothed density
ggplot(df, aes(x = HourFraction)) +
geom_density(fill = "#1DB954", alpha = 0.6, linewidth = 1) +
scale_x_continuous(breaks = 0:23, labels = sprintf("%02d", 0:23)) +
labs(
title = "Smoothed Density of Messages by Time of Day",
x = "Hour of Day",
y = "Density"
) +
theme_dark(base_size = 14)
}
Discord_HourDensity(CleanTime)
document()
rm(list = c("Discord_DailyTop", "Discord_HourDensity", "Discord_UserDailyActivity"))
setwd("..")
install("RiceMessageVisualization"
setwd("..")
setwd("..")
install("RiceMessageVisualization")
setwd("C:\Users\siper\Documents\College\Fall 2025\LIS 4370 R Programming\Final\RiceMessageVisualization")
setwd("C:\\Users\\siper\\Documents\\College\\Fall 2025\\LIS 4370 R Programming\\Final\\RiceMessageVisualization")
install("RiceMessageVisualization")
setwd("C:\\Users\\siper\\Documents\\College\\Fall 2025\\LIS 4370 R Programming\\Final\\RiceMessageVisualization")
library(RiceMessageVisualization)
setwd("C:\\Users\\siper\\Documents\\College\\Fall 2025\\LIS 4370 R Programming\\Final\\RiceMessageVisualization")
CleanTime <- Discord_TimeConvert(FinalProjectData)
library(RiceMessageVisualization)
library(readxl)
ProjectData <- read_excel("FinalProjectData.xlsx", sheet = 1)
View(CleanTime)
Discord_TopUsersCumulative(CleanTime, datetime_col = "Timestamp_clean", user_col = "Author", top_n = 10, points = TRUE)
